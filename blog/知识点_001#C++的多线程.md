## C++11的多线程相关

1. volatile: 在c++中，这个关键字主要是表示当前值每次读取的时候都需要从内存中读取，不能使用寄存器缓存的值。有的人很容易把他的作用和atomic或者使用mutex实现的原子操作弄混，实质上他们的意义是完全不同的。volatile除了用在io映射内存之类地方之外，它主要的一个作用就是用在如下类似的代码上面
```
volatile bool ready = false; //如果不加static就整个源程序都可以访问,不过其他地方要用extern声明一下

void initiazer(int &&ref)
{
	std::cout << "Inside thread: " << std::this_thread::get_id() << "	ref: " << ref << std::endl;
	//std::this_thread::sleep_for(std::chrono::milliseconds(1));
	ready = true;
}

int main()
{
	std::thread th(initiazer, int(6));

	int counter = 0;
	while (!ready)
	{
		counter++;
		std::cout << "\nready is false" << std::endl;
		//break;
	}

	std::cout << "\nready is true " << counter << std::endl;

	th.join();

	getchar();
	return 0;
}
```
我在vs2015中测试了一下，当不加volatile修饰ready变量时，主线程是有可能因为编译器优化而陷入死循环，即每次都从寄存器读取ready，发现都是false。当我在循环中加上“std::cout << "\nready is false" << std::endl;”这行代码的时候, 主线程可以正常读到ready被另一个线程修改的值，有可能是这行代码改变了编译器生成的汇编代码，导致ready无法再使用寄存器中的值，又或者是同时使用stream的时候进行了线程同步。


## 参考文献

- [翻译：C++ 11 线程、锁和条件变量](https://fzheng.me/2016/08/11/cpp11-multi-thread/)

- [C++ 参考手册--cppreference](https://zh.cppreference.com/w/cpp/utility/functional/function)


>未完待续